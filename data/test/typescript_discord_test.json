{"ids": ["148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184"], "dialog": [["Hello! \n Can someone explain me what means this statement  @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)  , please? \n \n Here is the context where this statement was used: \n @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) \n public ResponseEntity<Order> registerOrder(@RequestBody List<Product> products, @RequestParam( badgeCode ) String waiterBadgeCode) { \n return new ResponseEntity<>(orderService.registerOrder(products, waiterBadgeCode), HttpStatus.CREATED)  \n }", "what \n where did you come from \n why did you ping me", "yeah, please don't ping random people in the future", "Can you help me? Sry for ping", "uh", "ok, sry\ud83d\ude05", "im not good at java \n sorry \n i come here to ask questions only lol", "it ok, not problem\ud83d\udc4d"], ["When reading data from db, lets say as User, is it correct to use Partial<User> here?", "No, there will be fields that are not nullable which you will wont want to handle the undefined case for. Your User interface should match up to the databases nullable fields by having them be optional", "Interesting. But a User record in the database could always have a field missing (let's say by hand). What would happen if reading such a record as User and then accessing the missing field .name as non optional?", "@Deleted User It's up to decide how much you trust your database to have complete/accurate data in it. If you don't trust your database, though, I'm not sure Partial is enough, as the database could also have the wrong type of data, not just missing fields. I think trusting the data to be accurate is generally reasonable, but if you want to distrust your data, I'd use something like zod (https://github.com/colinhacks/zod) to validate it.", "@Retsam19 thx", "!close"], ["I'm using Dijkstra to compute SP in in an edgeweighted undirected Graph. The implementation has a method to return the SP, however if there are multiple SP (equal weight) how would I go about adding a method to the implementation of Dijkstra to return all single shortest paths and not just one? Any good ideas?", "Thx.", "/run java  \n System.out.println( test :D )  ", "XD", "well dijkstra is just an extension of depth-first search that follows the shortest path \n So then you'll need to maybe do one first-pass to determine the shortest path length, and then you go back and find all paths of that length", "So go through all the bags to find which sum of edges equals SP?", "/run java \n  System.out.println( * )  \n System.out.println( ** )  \n             System.out.println( *** )  \n             System.out.println( **** )  \n             System.out.println( ***** )  \n             System.out.println( ****** )  \n            System.out.println( ******* ) ", "triangle :D", "Please conduct the construction of triangles and other non-related activities in \u2060bot-cmds"], ["Hi all, I've got the typescript error in this code (Property 'table' does not exist on type 'Function'). How can I fix it. Thanks.", "@iousphed TS doesn't really provide types for this.constructor, hence why it's Function. I'd guess because it's a fairly rarely used property and it'd be complicated to get this.constructor right, in general. I'd probably just cast, like console.log('bump', (this.constructor as typeof Base).table)", "It works. Thank you so much.", "!close"], ["Hey all, this is probably a shot into the blue, but is there a way to define a union type based on files in a directory? E.g. for following files in an events directory events/ \u251c\u2500 foo.event.ts \u251c\u2500 bar.event.ts I'd like to have a type eventName that contains all possible names in events type eventName = 'foo' | 'bar' Would that be possible in TS or would I have to manually define the union type?", "!title union type from files in directory", "nope typescript doesn't know about paths", "Ah shucks, but thanks for the quick answer!", "!close"], ["Hi, I have a type:", "Hi, I have a type: export declare type FormProps<DataType> = { onSubmit?: (data: DataType, event: React.FormEvent<HTMLFormElement>) => void | Promise<void>  } I would like to create a function that conforms to the onSubmit function: const handleSubmit = () => {} How do I pick out that type def?", "Could do: const handleSubmit: FormProps<YourType>[\"onSubmit\"] = (data, event) => {} Might make sense to extract that inner type out to its own type, for convenience, though.", "ah thanks \ud83d\ude42 it's unfortunately a library type so I have no control", "Ah, yeah, makes sense."], ["What's the difference between { id: string  categoryId: string  }[] and [{ id: string  categoryId: string  }]?", "The former is an array with 0-N elements of the type { id: string  categoryId: string }, the latter is a one element tuple (fixed size array) containing that", "Is there any way to convert the latter to the former or the other way around if that makes sense? Trying to fix Argument of type '{ id: string  categoryId: string  }[]' is not assignable to parameter of type '[{ id: string  categoryId: string  }]'. Target requires 1 element(s) but source may have fewer.", "That's probably a mistake by whoever defined the types for the arguments of that function, this is a very common mistake from beginners... You could do foo([arr[0]])", "Alright, thank you so much Gerrit0 for the help and quick reply", "!close"], ["how can one add an event to a class? (if you have docs to help me with this id also be thankful)", "What event?", "sorry for my bad phrasing! an event listener", "Add event listener to a class? What are you doing with the class?", "If you want your class to support event emitters you need to extend the event emitter class. But the events you can listen will be locked to that class, it can not receive events from other classes unless they extend the original class", "https://nodejs.org/api/events.html", "Nodejs? Doesn't that go into \u2060ts-node then?", "@ts-check, that's about https://www.npmjs.com/package/ts-node", "thank u so much to all of you :pepechristmas:", "The \u2060ts-node channel you mean?", "Yes", "!close"], ["How do I accomplish the union type that I want?", "basically my ban API returns BanResponseServer, and in my game's code I am trying to inject moderatorName into BanResponse when banned is true (because I am getting their username after the request).", "type BanResponseServer = | { banned: true reason: string unbanDate: string moderatorId: number } | { banned: false }", "type BanResponse = BanResponseServer & {banned: true, moderatorName: string}", "There might be a better way to do it... but this works", "Actually, I think you can just use Extract", "Thank you!"], ["Hi folks. I need some help please", "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.(2464)", "I don't understand why if paramKey is of type const paramKey: { readonly item1:   item1prop    readonly item2:   item2prop    readonly item3: null  }[T] then if (paramKey != null) { wouldn't reduce it to:   item1prop   |   item2prop   ?", "Why it doesn't remove the null?", "What the heck?", "Is it a bug? \ud83d\ude42", "Why does this work then?", "I just replaced if (paramKey != null) with ensureNotNull(paramKey)  which is a type guard"], ["can I call two functions with optional changin in the template? HasValue ? function1()  function2() : null", "you could use a iife (Immediately invoked function expression)", "(hasValue ? (() => { function1()  function2()  })() : null)", "but tbh it's kinda ugly", "idk if you have control over the functions you wanna call to return a promise, so you can chain them", "or maybe if you are returning a value, you could return early if(!hasValue) return null  function1()  function2() ", "also, how are you trying to   chain   those calls?", "right wow that's really helpful", "I want to chain the call in order. I just created a function to do as you suggested", "but calling the iife won't return anything", "what do function1 and function2 return and need as parameter?", "sorry my ignorance what is iife ?", "an Immediately invoked function expression a function without a name you create on the spot and call immediately this basically (() => {})() or (function() {})()", "right thanks a lot", "I don't need to return just invoke two functions", "any harms using iife? instead of normal function?", "no, not that different", "hum, now that I think about it, you could also write hasValue ? function1() || function2() : null // only works if function1 returns a falsy value", "or hasValue ? function1() && function2() : null // only works if function1 returns a truthy value", "there is no return of both functions", "hey, are you a volunteer here or Angular or React developer", "if they both return void in TS, it means they return undefined in JS, so falsy", "nah, just a volunteer here", "are you a Angular or React Developer in the industry?", "oh, haha, no, I'm still a student (final year in CS tho) but I've some (limited) experience with both Angular and React", "but it seems like you're knowledgeable in terms of Typescript haha good on you", "yeah, bc I mostly do backend stuff (nodejs) so TS but no UI framework/lib", "right. thanks for that mate"], ["Hi folks. I need some help please", "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.(2464)", "I don't understand why if paramKey is of type const paramKey: { readonly item1:   item1prop    readonly item2:   item2prop    readonly item3: null  }[T] then if (paramKey != null) { wouldn't reduce it to:   item1prop   |   item2prop   ?", "Why it doesn't remove the null?", "What the heck?", "Is it a bug? \ud83d\ude42", "Why does this work then?", "I just replaced if (paramKey != null) with ensureNotNull(paramKey)  which is a type guard"], ["hi so i know totally nothing about typescript but i wanna ask is there a way to get into sourcecode of this project", "https://deno.land/x/hypixel@v3.1.1/Client.ts?s=RateLimitData", "i would like to know from what keys from api this code gets reset value", "okay thats source code now how can i find where its defined", "https://github.com/zikeji/node-hypixel/search?q=reset", "aight thanks"], ["Hi, Can't believe I haven't run into this yet... Say I have an array of type A or type B const arr : (A | B)[] = ... If those types are arbitrary, how would I go about looping through that array and determining which element is which type (i.e.): arr.forEach(el => { if (typeof el === A) { aFunc(el) } else { bFunc(el) } })", "It depends on the types, but you need some kind of narrowing function https://www.typescriptlang.org/docs/handbook/2/narrowing.html", "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates Documentation - Narrowing Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.", "Got it - so it can't really be arbitrary types? Unless you were to provide a narrowing function of sorts that involves A or B say to a function", "it could be you'd then be using generics but yeah, you'd also need to provide the type predicate function", "got it that makes sense thanks!"], ["hi, so i have an error when i use tsc -init in vsc error: tsc : File C:\\Users\\juraj\\AppData\\Roaming\\npm\\tsc.ps1 cannot be loaded because running scripts is disabled on this system. For more information, see about_Execution_Policies at https:/go.microsoft.com/fwlink/?LinkID=135170. At line:1 char:1 + tsc -init + ~~~ + CategoryInfo : SecurityError: (:) [], PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess", "The way I got around this problem was to bash instead of powershell, but if you want to use Powershell you need to follow that link in the error message. Or ZHS and Fish also works.", "ok thx i just used cmd", "No problem!"], ["Is dynamic evaluation of types possible? \n Ex. \n class Holder { \n obj = {} \n AddKey(key, val) => ... \n } \n ... \n holder.AddKey('someKey', 123) \n holder.AddKey('another', true) \n return GetObj() // And evaluate that to `{ someKey: number, another: boolean }` \n holder.AddKey('third', 'text') \n return GetObj() // `{ someKey: number, another: boolean, third: string }` \n \n I figured the maybe, since TS can evaluate guards (?)", "probably not, that would be too expensive, consider \n const arbitrary = () => Math.random() < 0.5  \n if (arbitrary())  {  \n AddKey('a')  \n } else if (arbitrary()) { \n AddKey('b') \n } else  // etc \n it would get very computationally intensive easily for large, branching code, and since you can't really stop analyzing a type before it's complete, that would probably slow down real-time extensions, linters, and interpreters/compilers to a halt", "Ah, that makes sense. Thank you! \n !close"], ["This isn't valid but is it close? \n type ValidSome<T> = (value: unknown | undefined) => typeof value extends T ? undefined | string \n \n export const validateName: ValidSome<string> = (value) => \n value ? undefined :  Please Enter a Value  \n \n Generic fn if the value is the expected type then undefined, otherwise error message.", "do you mean the type isn't valid, or the function itself isn't valid? the type looks fine to me, although value could just be unknown \n (although why not just have it throw an error, or just let typechecking do its job?)  \n also the undefined in the return type could be void", "so I made a dumb mistake with undefined | string should be undefined : string . I was getting syntax errors on the following lines expecting : or   and thought I used extends wrong/ \n I was trying to see if I could get enough types into this to know that name used in person but I cannot \n const newErrors = { \n name: validateName(name), \n } \n if (isNotEmpty(newErrors)) { \n setErrors(newErrors)  \n return \n } \n const result = await createPerson({ \n Person: { \n name \n }})", "!close"], ["Hi! I'm defining a type named Error that can also include a field with the  standard  Error type. Obviously this causes issues, how can I explicitely import the standard Error type so that I can rename it? For some reason import { Error as ErrorStd } from  typescript   doesn't work. Thanks in advance.", "In the meantime I've obviously renamed my type to avoid collisions but still I'd be able to just call it Error.", "The problem is that Error is not exported from anywhere, it's a global declaration.  Both DOM (browser) and Node environments declare a top level Error object \n Open a browser console or a Node REPL and type  Error  \n you should see a constructor function \n calling your type Error is a Very Bad Idea \n you absolutely should not do that, unless you're going to run in a custom environment that is neither a browser nor Node/Deno/etc \n and does not have an existing global Error interface \n in which case you should make yours look like the Error interface from one of those environments", "Thanks for the answer \ud83d\ude42"], ["Hi all, I have a question: is it possible to exclude one variant of record from type definition?  \n Ex.: \n type Keys = 'a' | 'b' | 'c' | 'd'  \n type ValidState = Exclude<Record<Keys, boolean>, Record<Keys, false>>  \n \n I would like to exclude object where all keys are false ", "!title Invalid state exclusion \n TypeScript  \u91cd\u547d\u540d\u9891\u9053\u4e3a\uff1apyskp - Invalid state exclusion", "@piotr.pysk Exclude operates on a union, and Record<Keys, boolean> is not a union.", "Is there replacement utility type for such case, or snippet which could help me achieve this?", "I guess you could do something like this: \n type ExcludeValues<T, U> = { [K in keyof T]: Exclude<T[K], U> } \n \n type Keys = 'a' | 'b' | 'c' | 'd'  \n type ValidState = ExcludeValues<Record<Keys, boolean>, false> \n", "It isn't working. ExcludeValues returns object with all values as true. I would like to have all variants of Record<Keys, boolean> except version where all keys are false. \n Other way, my problem is to type state when I have names (Keys), which each could be disabled/enabled, but at least one has to be enabled. ", "Well, then switch false for true, but Record<Key, true> would be a lot easier than this ExcludeValue thing.", "However, I don't think it's going to solve this problem, necessarily. ", "!close"], ["function x(a: string): void  \n function x(b: number): void  \n function x(a: string | number) {} \n \n declare const y: string | number  \n \n x(y)  \n ~~~~~ \n Why this gives error?", "@orange3997 When calling an overloaded function, the parameter type is compared against the overload signatures \n In your case, string | number is not compatible with either signature, so it fails \n Need another function x(a: string | number): void  signature to make it work", "@Chen Sida Appreciated! \n !close"], ["How can I overwrite functions (specifically their return value) if the function is defined in an interface?", "I think you can use the omit utility type for this \n interface A { \n a: string \n myFunction: () => string \n } \n \n interface B extends Omit<A, 'myFunction'> { \n myFunction: () => number \n } \n \n const example: B = { \n a: 'hello', \n myFunction: () => 1 \n}", "Maybe my example is a little more complicated. Say I have: \n function fun1(p:string):number  \n function fun2(p:number):string  \n function fun(p: string | number) { \n // some code here \n } \n How would I got about putting a function like this into an interface, where the interface has reference to fun1 and fun2 and would be able to tell me the return type of fun given the type of parameter?", "((p: string) => number) & ((p: number) => string) ", "!ts", "this seems to just work as well", "Gotcha thanks so much! \n !close"], ["Is there any way/trick to omit the second generic type? \n \n get<T extends Container, U extends keyof T>(key: U): T[U] {...} \n \n  get<MyContainer, 'myContainerKey'>('myContainerKey')  // OK \n get<MyContainer>('myContainerKey')  // Error", "nope \n the closest you could do is return a nested function with the second generic", "@Deleted User Thanks! \n !close"], ["I need to use node-forge in my new app, the tutorial said to import it like this: \n \n import * as forge from 'node-forge'  \n \n But the thing is I just need some parts of the module like: \n \n forge.pki.certificateFromAsn1 \n forge.kem.kdf1 \n forge.kem.kdf2 \n \n How I can just import the required parts? \n \nI tried to import like import {forge.kem.kdf1} but I get this error message: \n\n Module ' node-forge ' has no exported member 'kdf1'", "You can import individual exports like: \n import { pki , kem } from 'node-forge'  \n There's not really any way to go farther than that on the import, though.  You can't directly pull in kdf1 because it's not exported directly from the module.  It's inside the kem namespace.", "!close", "Thanks \ud83d\ude04"], ["Why doesn't Omit play nice with index signatures: ", "Only if I remove the index-signature will the last line typecheck. \n Is there any other way of making that compile?", "i don't think they're going to change Omit since it'd be a breaking change \n but using newer features like above, is one way to fix things", "I see, thank you! Is there any reason to not use that instead of Omit in all places? \n And can I somehow  replace  the built-in one? \ud83d\ude42", "not without a lot of work, i don't think... \n i wouldn't recommend it since if you turn it into a library eventually, the users would have to do the same thing \n i think you'd be able to export it from a module though, so all users would have to do is import { Omit } from 'the_module'", "probably not \n i'm guessing the reason most people use the built-in omit is just because having an explicit index signature is a very uncommon situation", "Is it? That's strange. In any case - thank you for the detailed answer!"], ["What should be the return type of the doubler function?  \n type Numbers = number | Array<Numbers>  \n \n const doubler = (value: Numbers) => Array.isArray(value) \n  ? value.map(entry => doubler(entry)) \n  : value * 2 ", "!ts \n i changed Array.isArray to typeof  === 'number' because typescript doesn't seem to like that []", "I see, thank you", "I was trying  \n type Numbers = number | Array<Numbers>  \n\n const doubler = (value: Numbers): Numbers => Array.isArray(value) \n ? value.map(entry => doubler(entry)) \n : value * 2  \n // ^? \n\n const twos = doubler([[1, 2], [3, 4]] as [number, number][]) \n // ^?", "!ts", "wait", "But this lost type information on two", "!ts", "note that the [] is a hack to get arrays to infer as tuples ([number, number]) instead of arrays (number[])", "thanks @Deleted User any idea why the prev approach did not infer type information?", "it's not a generic \n if your return type is just Numbers... typescript wouldn't exactly go off and give you a different return type on its own", "I see! \n Thanks again \n !close"], ["How can I make properties nullable. For example {x: number, y: number} to {x: number | null, y: number | null}", "@itsramiel \n type T = { x: number, y: number }  \n type NT = { [K in keyof T]: T[K] | null } ", "Can we ake NT a generic? How would that be? \n type NT<T> = { [K in keyof T]: T[K] | null }  but how would we restrict T to be an object?", "T extends object ?", "Yes, that \n But you don't have to", "Thank you \n !close"], ["Can you constraint numbers in TS? I would like the ability to restrict a number to be in a range (like 0-360). According to this SO thread, it appeared to be something that was coming, but I am a bit overwhelmed by all different ways to do it. \n https://stackoverflow.com/questions/39494689/is-it-possible-to-restrict-number-to-a-certain-range \n\n radians = function(degrees: number): number { \n return degrees * Math.PI / 180  \n } \n\n Let's say I don't want the angle to be greater than 360 or less than 0, how could I enforce that?  \n Stack Overflow \n Is it possible to restrict number to a certain range \n Since typescript 2.0 RC (or even beta?) it is possible to use number literal types, as in type t = 1 | 2 . Is it possible to restrict a type to a number range, e.g. 0-255, without writing out 256 n...", "most of those answers are still valid \n there is no good way to do that in TS \n you could create  a union type with a few predefined values (like type Degrees = 0 | 90 | 180 | 270), but it doesn't scale well with lots of values \n this is probably something you should take care of at runtime anyway \n also, you can just degree % 360 to have a range between 0 and 360 \n https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder", "Ah, that's a good idea. \n\n When you say 'take care of at runtime' are you saying using logical statements like if to check whether the variable is in the correct range?", "right \n but as I said, it's probably best if you use the remainder operator \n to allow for values greater than 360 if it's a desired behavior  \n also, don't forget to check for NaN which is technically a number \n https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN \n", "Yes, that makes sense! Thanks!!! \n !close", "not quite... \n you may need (degree % 360 + 360) % 360 ", "negative numbers, I know", "exactly \n !close"], ["Why this does not work? \n declare function x(x: 'number'): void  \n declare function x(x: 'string'): void  \n declare function x(x: 'number' | 'string'): void  \n\n x( abc ) ", "You have the types in quotes, it's trying to match it to the string literals 'number' and 'string' \n declare function x(x: number): void  \n declare function x(x: string): void  \n declare function x(x: number | string): void  \n\n x( abc ) ", "holly, god. Thanks. Am I drunken? \n !close"], ["is there a good way to change a variable's type to never? I have an stream that I'm cloning and I don't want the original stream to be used anywhere after the clone or read. Maybe theres a better way to invalidate a type after a certain condition is met?", "!title Set type to never after it's been used \n TypeScript \n \u91cd\u547d\u540d\u9891\u9053\u4e3a\uff1a\n Eezergoode - Set type to `never` after it's been used ", "daring today arent we", "might just be late on a friday and my brain is mush.", "https://tsplay.dev/WJ5Dkm \n TS Playground - An online editor for exploring TypeScript and JavaS... \n The Playground lets you write TypeScript or JavaScript online in a safe and sharable way. \n have no idea why you want to do this in prod code \n oh wait \n it doesnt work \n ah \n https://tsplay.dev/wjQxMW \n TS Playground - An online editor for exploring TypeScript and JavaS... \n The Playground lets you write TypeScript or JavaScript online in a safe and sharable way. \n oh my god \n my brain is also mush", "lol", "simplest version: https://tsplay.dev/wervYN \n TS Playground - An online editor for exploring TypeScript and JavaS... \n The Playground lets you write TypeScript or JavaScript online in a safe and sharable way. \n abusing assertions: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions \n Documentation - TypeScript 3.7 \n TypeScript 3.7 Release Notes \n cons: \n cant return anything from the function \n needs explicit type annotation \n doesnt respect async code (and will never) \n pros: \n works", "well shit it works, but my other func are accepting it as a param. what gives?", "Hmm maybe I'm just misunderstanding never now. Your assert abuse did what I asked though so thank you for the help! I think I might need to try to abuse opaque types or something now to make it so I can't pass it to other funcs", "!close"], ["Hey, if i implement a constant that returns a promise, does the program fetch the data every time the constant is called or does it do it once and just returns that value  \n Example:  \n const data: settings[] = await prisma.settings.findMany()", "!title How does constants work within typescript. \n TypeScript \n \u91cd\u547d\u540d\u9891\u9053\u4e3a\uff1a\n Tropic - How does constants work within typescript.", "@tropic Well, your constant  there doesn't return a promise, it's the result after the promise is resolved.", "hmm ok", "But yeah, if you reuse a promise, the result is shared, the promise is not-rerun. \n\n For example, this will only call apiCall once, no matter how many times loadData is called. \n\n let dataPromise: Promise<string[]> | undefined  \n\n function loadData() { \n if(!dataPromise) { \n dataPromise = apiCall()   \n } \n return dataPromise    \n } \n (Though that means if the request to load the data fails, the failure will be cached, too - realistically you'd probably want to 'uncache' the promise in that ase)", "Oh ok that makes sense now \n ty ty \n !close"], ["I have a class, Parent, and three child classes, A, B, C. I want to create an array of Parent objects and be able to put in any permutation of A, B, C child instances. In code:  \n\n let theArr : Array<Parent> = [new A(), new B(), new C()] ", "can you show a playground", "What site do people use for a playground demo?", "https://www.typescriptlang.org/play \n TS Playground - An online editor for exploring TypeScript and JavaS... \n The Playground lets you write TypeScript or JavaScript online in a safe and sharable way.", "which is linked from \u2060how-to-get-help , which is linked in the response that the bot just made above", "So you want array of A, B, C and Parent? \n theArr: Array<A | B | C| | Parent> = [new A(), new B(), new C()]  \n \n If you want array of A, B, C then remove Parent from the union type  \n If you know it's gonna contain fixed number of elements then you can use tuple type: \n let theArr: [A, B, C] = [new A(), new B(), new C()] ", "I'd like to have an array of instances of a class or any of it's subclasses. That way if I add another subclass of Parent at a later date, I don't need to go back through and update this array definition.", "The whole point of subclasses is that they are assignable to the parent, so Array<Parent> can hold subclasses as well", "Damn. Sorry everyone. It was working as expected. I was getting an error for something else. \n Thanks for the help.", "Wait what? Didn't know that", "I mean that's the whole point of inheritance in the first place", "(the assignment on the last line fails, because p can only access the Parent part of Child) \n but we're basically getting into OOP 101 here, if you need help with the fundamentals there are plenty of good books out there", "No, no, I just didn't know TS aloows that"], ["I'm trying to write an overload for a constructor, but I keep getting the error: \n This overload signature is not compatible with its implementation signature \n  No matter how I write it, the error seems to pop up on one of the overloads \n    constructor()  \n    constructor(name?: string) \n    constructor(options?: FormOptions)  \n   constructor(name: string, options: FormOptions) { \n\n    }", "The implementation needs to be able to handle all forms \n So the final constructor needs to be something like: \n\n constructor(nameOrOptions?: string | FormOptions)", "Ahh okok, that makes sense tyty \n idk why I didn't think of that \n !close"], ["what does this mean in ts/js? \n if( _speedX || _modifierX ){", "does it check if those two values are not 0 or what?", "https://mdn.io/Logical_OR \n it checks for either of them being truthy", "wdym \n those two stuff are numbers", "https://mdn.io/truthy", "so it checks if one of those values are not 0", "yes", "!close"], ["Hi I want to make some performance testing where I want to create 1000 promises and execute them all at once, but I struggle to get it running. \n const fetch = require( node-fetch )  \n\n const request = async() =>{ \n    const response = await fetch('https://jsonplaceholder.typicode.com/todos/1')  \n    const data = response.json()  \n    return data  \n    } \n\n const main = async() =>{ \n    tasks = []  \n    for( i=0  i<10  i++){ \n    tasks.push(request)  \n    } \n  \n    const responses = await Promise.all(tasks)  \n    console.log(responses) \n }\n\n main()  \n\n It seems like the functions don't get called", "You're not calling the request function \n You're just pushing references to the function", "Isn't Promise.all calling them?", "No. \n Promise.all is a way to wait for a group of already running promises to finish", " You mean calling like  \n const responses = await Promise.all(tasks.map(t=>{ \n        return t()  \n    }))  \n ?", "If request is an array of request functions, then yes \n Err \n If  tasks ", "yes, I push references of the request function into the task array. @RogerC Thank you for the quick help \ud83d\ude42", "you could just tasks.push(request())"], ["I need help constructing a array using two different objects", "I'm trying to do the following: \n\n const plugins: PluginManifest[] = Object.values(window.Aliucord.pluginManager.plugins).map((p) => p.manifest) && Object.values(window.Aliucord.pluginManager.disabledPlugins).map(p => p)  \n I want the settings array to have the data from both of these objects", "You probably want this:  \n const plugins: PluginManifest[] = [ \n  ...Object.values(window.Aliucord.pluginManager.plugins).map((p) => p.manifest), \n  ...Object.values(window.Aliucord.pluginManager.disabledPlugins).map(p => p), \n ] ", "Yup, thanks \n !close"], ["How can I download a file from an URL?", "node? \n with new enough versions, i believe fetch comes built-in with node via undici? \n otherwise, the node-fetch module \n  or you can use undici directly, i think it has a different api though", "thanks I will try that"], ["How do I type a generic method that returns the object/instance that the method was called on? In other words, it returns this. Does typescript have a way to define that as a generic?", "this can be used in type position, it sounds like that may be what you want? \n like you want to be able to define the method on a superclass but have it return instances of subclasses if it's called on them, yeah?", "Aha! This helps so much. I wanted to do it in a generic way, so I was using a type, but it seems like Interface is what I needed. Here's the solution I came up with \n interface SavableBubbleModel { \n  save(): Promise<this>  \n } \n Thank you @mkantor \n !close "]], "role": [[0, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0], [0, 1, 0, 1], [0, 1, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0], [0, 1, 0, 1, 1, 1, 0], [0, 1, 0], [0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 0, 1, 1, 1], [0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1], [0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 1, 0], [0, 1, 0], [0, 1, 1]], "edge": [[[0, 1], [0, 2], [1, 3], [3, 4], [2, 5], [3, 6], [6, 7]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], [[0, 4], [4, 5]], [[0, 1], [1, 2], [2, 3]], [[0, 1], [1, 2], [2, 3], [3, 4]], [[0, 1], [1, 2], [2, 3], [3, 4]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [6, 7]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18], [18, 19], [19, 20], [20, 21], [21, 22], [22, 23], [23, 24], [24, 25], [25, 26], [26, 27], [27, 28], [28, 29]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], [[0, 1], [1, 2], [2, 3]], [[0, 1], [1, 2]], [[0, 1], [1, 2], [2, 3]], [[0, 1], [1, 2], [2, 3]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8]], [[0, 1], [1, 2]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]], [[0, 1], [1, 2]], [[0, 1], [1, 2], [2, 3]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]], [[0, 1], [1, 2]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12]], [[0, 1], [1, 2]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]], [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]], [[0, 1], [1, 2], [2, 3]], [[0, 1], [1, 2]], [[0, 1], [1, 2]]], "label": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}